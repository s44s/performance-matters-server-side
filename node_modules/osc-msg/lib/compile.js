"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Tag = require("./Tag");
var utils = require("./utils");

function compile(object, opts) {
  if (object === null || (typeof object === "undefined" ? "undefined" : _typeof(object)) !== "object") {
    object = { args: [object] };
  }
  if (Array.isArray(object)) {
    object = { args: object };
  }
  if (Array.isArray(object.elements) || utils.isTimeTag(object.timetag)) {
    return compileBundle(object, opts);
  }
  return compileMessage(object, opts);
}

function compileBundle(object, opts) {
  var timetag = utils.toTimeTag(object.timetag);
  var elements = utils.toArray(object.elements).map(function (element) {
    if (utils.isBlob(element)) {
      return compileRawData(element);
    }
    return compile(element, opts);
  });
  var oscType = "bundle";

  var bufferLength = 0;
  // #bundle_
  bufferLength += 8;
  // timetag
  bufferLength += 8;
  // blob size
  bufferLength += elements.length * 4;
  bufferLength += elements.reduce(function (bufferLength, element) {
    return bufferLength + element.bufferLength;
  }, 0);

  var error = elements.reduce(function (error, element) {
    return error || element.error;
  }, null);

  return { timetag: timetag, elements: elements, bufferLength: bufferLength, oscType: oscType, error: error };
}

function compileRawData(buffer) {
  var oscType = "<DATA>";
  var bufferLength = buffer.length || buffer.byteLength;

  return { buffer: buffer, bufferLength: bufferLength, oscType: oscType };
}

function compileMessage(object, opts) {
  if (opts.strict && typeof object.address !== "string") {
    return {
      address: "", types: "", values: [], bufferLength: 0, oscType: "message",
      error: new TypeError("OSC Message must contain an address")
    };
  }

  var address = utils.toAddress(object.address);
  var args = utils.toArray(object.args).map(function (value) {
    return convertTypedValue(value, opts);
  });
  var items = build(args, opts);
  var types = items.types;
  var values = items.values;
  var error = items.error;
  var oscType = "message";

  var bufferLength = items.bufferLength;

  if (typeof address === "number") {
    bufferLength += 4;
  } else {
    bufferLength += utils.size4(address.length + 1);
  }
  bufferLength += utils.size4(types.length + 2);

  return { address: address, types: types, values: values, bufferLength: bufferLength, oscType: oscType, error: error };
}

function convertTypedValue(value, opts) {
  if (utils.isNone(value)) {
    return { type: "null", value: null };
  }

  switch (typeof value === "undefined" ? "undefined" : _typeof(value)) {
    case "number":
      if (opts.integer) {
        return { type: "integer", value: value };
      }
      return { type: "float", value: value };
    case "string":
      return { type: "string", value: value };
    case "boolean":
      return { type: value.toString(), value: value };
    default:
    // do nothing
  }

  if (Array.isArray(value)) {
    return { type: "array", value: value.map(function (value) {
        return convertTypedValue(value, opts);
      }) };
  }

  if (utils.isBlob(value)) {
    return { type: "blob", value: value };
  }

  if (value instanceof Date) {
    return { type: "timetag", value: utils.toTimeTagFromDate(value) };
  }

  return value;
}

function build(args, opts) {
  var values = [];

  var types = "";
  var bufferLength = 0;
  var error = null;

  for (var i = 0; i < args.length; i++) {
    var value = args[i];

    if (Tag.types.hasOwnProperty(value.type)) {
      var type = Tag.types[value.type];

      if (opts.strict && !type.validate(value.value)) {
        error = new TypeError("Invalid date: expected " + value.type + ", but got " + JSON.stringify(value));
      }

      value = { type: value.type, value: type.valueOf(value.value) };

      values.push(value);
      types += type.tag;
      bufferLength += type.size(value.value);
    } else if (value.type === "array") {
      var items = build(value.value, opts);

      values.push.apply(values, items.values);
      types += "[" + items.types + "]";
      bufferLength += items.bufferLength;
      error = error || items.error;
    } else {
      error = new TypeError("Invalid data: " + value);
    }

    if (error !== null) {
      break;
    }
  }

  return { types: types, values: values, bufferLength: bufferLength, error: error };
}

module.exports = compile;